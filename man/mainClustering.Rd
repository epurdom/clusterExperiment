% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mainClustering.R
\docType{methods}
\name{mainClustering}
\alias{mainClustering}
\alias{mainClustering-character-method}
\alias{mainClustering,ClusterFunction-method}
\alias{getPostProcessingArgs,ClusterFunction-method}
\alias{getPostProcessingArgs}
\title{Cluster distance matrix from subsampling}
\usage{
\S4method{mainClustering}{character}(clusterFunction, ...)

\S4method{mainClustering}{ClusterFunction}(clusterFunction, x = NULL,
  diss = NULL, distFunction = NA, clusterArgs = NULL, minSize = 1,
  orderBy = c("size", "best"), format = c("vector", "list"),
  checkArgs = TRUE, checkDiss = TRUE, returnData = FALSE, ...)

\S4method{getPostProcessingArgs}{ClusterFunction}(clusterFunction)
}
\arguments{
\item{clusterFunction}{a \code{\link{ClusterFunction}} object that defines
the clustering routine. See \code{\link{ClusterFunction}} for required
format of user-defined clustering routines. User can also give a character
value to the argument \code{clusterFunction} to indicate the use of
clustering routines provided in package. Type
\code{\link{listBuiltInFunctions}} at command prompt to see the built-in
clustering routines. If \code{clusterFunction} is missing, the default is
set to "pam".}

\item{...}{arguments passed to the post-processing steps of the clustering.
The available post-processing arguments for a \code{ClusterFunction} object
depend on it's algorithm type and can be found by calling
\code{getPostProcessingArgs}. See details below for documentation.}

\item{x}{\code{p x n} data matrix on which to run the clustering (samples in 
columns).}

\item{diss}{\code{n x n} data matrix of dissimilarities between the samples 
on which to run the clustering}

\item{distFunction}{a distance function to be applied to \code{D}. Only
relevant if input is only \code{x} (a matrix of data), and
\code{diss=NULL}. See details of \code{\link{clusterSingle}} for the
required format of the distance function.}

\item{clusterArgs}{arguments to be passed directly to the \code{clusterFUN}
slot of the \code{ClusterFunction} object}

\item{minSize}{the minimum number of samples in a cluster. Clusters found 
below this size will be discarded and samples in the cluster will be given 
a cluster assignment of "-1" to indicate that they were not clustered.}

\item{orderBy}{how to order the cluster (either by size or by maximum alpha 
value). If orderBy="size" the numbering of the clusters are reordered by 
the size of the cluster, instead of by the internal ordering of the 
\code{clusterFUN} defined in the \code{ClusterFunction} object (an internal
ordering is only possible if slot \code{outputType} of the
\code{ClusterFunction} is \code{"list"}).}

\item{format}{whether to return a list of indices in a cluster or a vector of
clustering assignments. List is mainly for compatibility with sequential 
part.}

\item{checkArgs}{logical as to whether should give warning if arguments given
that don't match clustering choices given. Otherwise, inapplicable 
arguments will be ignored without warning.}

\item{checkDiss}{logical. Whether to check whether the input \code{diss} is
valid.}

\item{returnData}{logical as to whether to return the \code{diss} or \code{x}
matrix in the output. If \code{FALSE} only the clustering vector is
returned.}
}
\value{
mainClustering returns a vector of cluster assignments (if format="vector")
  or a list of indices for each cluster (if format="list"). Clusters less
  than minSize are removed.
}
\description{
Given input data, this function will try to find the clusters
  based on the given ClusterFunction object.
}
\details{
\code{mainClustering} is not meant to be called by the user. It is only an
  exported function so as to be able to clearly document the arguments for
  \code{mainClustering} which can be passed via the argument \code{mainClusterArgs} in
  functions like \code{\link{clusterSingle}} and \code{\link{clusterMany}}.

Post-processing Arguments: For post-processing the clustering,
  currently only type 'K' algorithms have a defined post-processing.
  Specifically
\itemize{
 \item{"findBestK"}{logical, whether should find best K based on average
  silhouette width (only used if clusterFunction of type "K").}
 \item{"kRange"}{vector of integers to try for k values if findBestK=TRUE. If
 \code{k} is given in \code{clusterArgs}, then default is k-2 to k+20,
 subject to those values being greater than 2; if not the default is
 \code{2:20}. Note that default values depend on the input k, so running for
 different choices of k and findBestK=TRUE can give different answers unless
 kRange is set to be the same.}
 \item{"removeSil"}{logical as to whether remove the assignment of a sample
 to a cluster when the sample's silhouette value is less than
 \code{silCutoff}}
 \item{"silCutoff"}{Cutoff on the minimum silhouette width to be included in
  cluster (only used if removeSil=TRUE).}
}
}
\examples{
data(simData)
cl1<-mainClustering(x=simData,clusterFunction="pam",clusterArgs=list(k=3))
cl2<-mainClustering(simData,clusterFunction="hierarchical01",clusterArgs=list(alpha=.1))
cl3<-mainClustering(simData,clusterFunction="tight",clusterArgs=list(alpha=.1))
#change distance to manhattan distance
cl4<-mainClustering(simData,clusterFunction="pam",clusterArgs=list(k=3),
     distFunction=function(x){dist(x,method="manhattan")})

#run hierarchical method for finding blocks, with method of evaluating
#coherence of block set to evalClusterMethod="average", and the hierarchical
#clustering using single linkage:
clustSubHier <- mainClustering(simData, clusterFunction="hierarchical01",
minSize=5, clusterArgs=list(alpha=0.1,evalClusterMethod="average", method="single"))

#do tight
clustSubTight <- mainClustering(simData, clusterFunction="tight", clusterArgs=list(alpha=0.1),
minSize=5)

#two twists to pam
clustSubPamK <- mainClustering(simData, clusterFunction="pam", silCutoff=0, minSize=5,
removeSil=TRUE, clusterArgs=list(k=3))
clustSubPamBestK <- mainClustering(simData, clusterFunction="pam", silCutoff=0,
minSize=5, removeSil=TRUE, findBestK=TRUE, kRange=2:10)

# note that passing the wrong arguments for an algorithm results in warnings
# (which can be turned off with checkArgs=FALSE)
clustSubTight_test <- mainClustering(simData, clusterFunction="tight",
clusterArgs=list(alpha=0.1), minSize=5, removeSil=TRUE)
clustSubTight_test2 <- mainClustering(simData, clusterFunction="tight",
clusterArgs=list(alpha=0.1,evalClusterMethod="average"))
}
