---
title: "clusterExperiment Vignette"
author: "Elizabeth Purdom and Davide Risso"
date: "`r Sys.Date()`"
bibliography: bibFile.bib
output: 
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{clusterExperiment Vignette}
editor_options: 
  chunk_output_type: console
---


```{r GlobalOptions, results="hide", include=FALSE, cache=FALSE}
knitr::opts_chunk$set(fig.align="center", cache=FALSE, cache.path = "clusterExperimentTutorial_cache/",  fig.path="clusterExperimentTutorial_figure/",error=FALSE, #make it stop on error
fig.width=6,fig.height=6,autodep=TRUE,out.width="600px",out.height="600px",
message=FALSE)
#knitr::opts_knit$set(stop_on_error = 2L) #really make it stop
#knitr::dep_auto()
```


# Introduction {#Intro}

The goal of this package is to help users to work with clusterings of single cell or other genomic data for common visualization tasks.

We provide a class `ClusterExperiment` that inherits from `SingleCellExperiment` to store the many clusterings and related information.

All of our methods also have a barebones version that allows input of matrices and greater control. This comes at the expense of the user having to manage and keep track of the clusters, input data, transformation of the data, etc. We do not discuss these barebone versions in this tutorial. Instead, we focus on using the `SummarizedExperiment` object as the input and working with the resulting `ClusterExperiment` object. See the help pages of each method for more on how to allow for matrix input.

Although this package was developed with (single-cell) RNA-seq data in mind, its use is not limited to RNA-seq or even to gene expression data.

For actual creation of the clusterings (i.e. running clustering algorithms) see our companion package `RSEC` which provides tools for implementing many different clustering algorithms in one package structure using the `clusterExperiment` object and which provides strategies for creating a unified clustering from these many clustering resutls.

# Quickstart {#quickstart}

In this section we give a quick introduction to the package and the `RSEC` wrapper which creates the clustering. We will also demonstrate how to find features (biomarkers) that go along with the clusters. 

## The Data {#data}

We will make use of a small single cell RNA sequencing experiment produced by Fluidigm and made available in the `scRNAseq` package. Fluidigm's original data (and that provided by  `scRNASeq`) contained 130 samples, but there are only 65 actual cells, because each cell library is sequenced twice at different sequencing depth. We have provided within the  `clusterExperiment` package a subset of this data set, limited to only those 65 cells sequenced at high depth[^1]. See `?fluidigmData` to see the code to recreate the data we provide here. 


We will load the datasets, and data containing information about each of the samples, and then store that information together in a `SummarizedExperiment` object. 

```{r,cache=FALSE}
set.seed(14456) ## for reproducibility, just in case
library(clusterExperiment)
data(fluidigmData) ## list of the two datasets (tophat_counts and rsem_tpm)
data(fluidigmColData)
se<-SummarizedExperiment(fluidigmData,colData=fluidigmColData)
```

We can access the gene counts data with `assay` and the metadata on the samples with `colData`. 

```{r}
assay(se)[1:5,1:10]
colData(se)[,1:5]
NCOL(se) #number of samples
```


## Filtering and normalization {#step0}

We will filter out lowly expressed genes: we retain only those genes with at least 10 reads in at least 10 cells.

```{r filter}
wh_zero <- which(rowSums(assay(se))==0)
pass_filter <- apply(assay(se), 1, function(x) length(x[x >= 10]) >= 10)
se <- se[pass_filter,]
dim(se)
```

This removed `r sum(!pass_filter)` genes out of `r NROW(fluidigmData[[1]])`. We now have `r NROW(se)` genes (or features) remaining. Notice that it is important to at least remove genes with zero counts in all samples (we had `r length(wh_zero)` genes which were zero in all samples here). Otherwise, PCA dimensionality reductions and other implementations may have a problem. 

Normalization is an important step in any RNA-seq data analysis and many different normalization methods have been proposed in the literature. Comparing normalization methods or finding the best performing normalization in this dataset is outside of the scope of this vignette. Instead, we will use a simple quantile normalization that will at least make our clustering reflect the biology rather than the difference in sequencing depth among the different samples.

```{r normalization}
#provides matrix of normalized counts
fq <- round(limma::normalizeQuantiles(assay(se)))
```

`SummarizedExperiment` objects allow for the storage of multiple data matrices of the same dimensions, so we will add this normalized data as an additional assay in our `se` object. Note that we will put the normalized counts first, since by default the `clusterExperiment` package uses the first assay in the object (see [Working with other assays](#multipleAssays) for how to switch between different assays)

```{r addToAssays}
assays(se) <- c(SimpleList(normalized_counts=fq),assays(se))
assays(se)
```

We see that we've added the normalized counts to our two existing datasets already (we've been working with the tophat counts, as the first assay, but also saved in our object are RSEM TPM values). 

## Creating a ClusterExperiment Object

This data comes with existing clusters in the columns "Cluster1" and "Cluster2" that came in the dataset; they refer to published clustering results from the paper. We will use the terms "Published1" and "Published2". 

```{r colnames}
wh<-which(colnames(colData(se)) %in% c("Cluster1","Cluster2"))
colnames(colData(se))[wh]<-c("Published1","Published2")
```

We will manually create a clustering object using these clusters

```{r createCE}
ceFluidigm<-ClusterExperiment(se, clusters=colData(se)[,wh], transformation=function(x){log(x+1)})
```

### The output 

We can look at the object that was created.

```{r CEprint}
ceFluidigm
```

The print out tells us about the clustering(s) that are stored (namely `r nClusterings(ceFluidigm)` clusterings)

`ceFluidigm` is a `ClusterExperiment` object. This is the basic class for this package and explained in greater detail in the section on [ClusterExperiment Objects](#ceobjects). In the object `ceFluidigm` the clusterings are stored along with corresponding information for each clustering. Furthermore, all of the information in the original `SummarizedExperiment` is retained. The print out also tells us information about the "primaryCluster" of `ceFluidigm`. Each `ClusterExperiment` object has a "primaryCluster", which is the default cluster that the many functions will use unless specified by the user. The "primaryCluster" for `ceFluidigm` has the label "Published1" -- which is the first of the clusterings in the matrix of clusterings we provide.

There are many accessor functions that help you get at the information in a `ClusterExperiment` object and some of the most relevant are described in the section on [ClusterExperiment Objects](#ceobjects). (`ClusterExperiment` objects are S4 objects, and are not lists). 

For right now we will only mention the most basic such function that retrieves the actual cluster assignments. 

```{r primaryCluster}
head(primaryCluster(ceFluidigm),20)
tableClusters(ceFluidigm)
```

Notice that the cluster identifications are encoded by consecutive integers, even though the different clusters have labels assigned to them. The functions in `ClusterExperiment` store the names of the clusters separately from the vector of identifications, discussed more in [ClusterExperiment Objects](#ceobjects). 

Notice that some of the samples are assigned the value of `-1`. `-1` is the value assigned in this package for samples that are not assigned to any cluster. Why certain samples are not clustered depends on the underlying choices of the clustering routine. This data came with `NA` values that were converted to `-1` values. Another special value is `-2` discussed in the section on [ClusterExperiment objects](#ceobjects)

We can change the primary cluster

```{r}
primaryCluster(ceFluidigm)<-"Published2"
tableClusters(ceFluidigm)
```

We'll set it back to the original

```{r}
primaryCluster(ceFluidigm)<-"Published1"
```

All of the the clusterings are saved in `ceFluidigm` object and can be accessed by the `clusterMatrix` function, that returns a matrix where the columns are the different clusterings and the rows are samples. We show a subset of this matrix here:

```{r clusterMatrix}
head(clusterMatrix(ceFluidigm))
```

The column names are the `clusterLabels` for each clustering and can be accessed (and assigned new values!) via the `clusterLabels` function. 

```{r clusterLabels}
head(clusterLabels(ceFluidigm))
```

### Visualizing the clusterings {#visualsummary}
`clusterExperiment` also provides many ways to visualize any set of clusterings stored in a `ClusterExperiment` object, as we'll show below). 

#### Visualizing many clusterings 
The first such useful visualization is a plot of all of the clusterings together using the `plotClusters` command. For this visualization, it is useful to change the amount of space on the left of the plot to allow for the labels of the clusterings, so we will reset the `mar` option in `par`. We also decrease the `axisLine` argument that decides the amount of space between the axis and the labels to give more space to the labels (`axisLine` is passed internally to the `line` option in `axis`).

```{r plotClusterRSEC}
defaultMar<-par("mar")
plotCMar<-c(1.1,8.1,4.1,1.1)
par(mar=plotCMar)
plotClusters(ceFluidigm,main="Published Fluidigm Clusters", whichClusters="all", colData=c("Biological_Condition"), axisLine=-1)
```

This plot shows the samples in the columns, and different clusterings on the rows. Each sample is color coded based on its clustering for that row, where the colors have been chosen to try to match up clusters across different clusterings that show large overlap. Moreover, the samples have been ordered so that each subsequent clustering (starting at the top and going down) will try to order the samples to keep the clusters together, without rearranging the clustering blocks of the previous clustering/row.

We also added a `colData` argument in our call, indicating that we also want to visualize some information about the samples saved in the `colData` slot (inherited from our original `fluidigm` object). We chose the columns "Biological_Condition" from `colData`, which correspond to the original biological condition of the experiment. The data from `colData` (when requested) are always shown at the bottom of the plot.

Notice that some samples are white. This indicates that they have the value -1, meaning they were not clustered. We can see that "Published1" appears to be a finer resolution clustering compared to "Published2" (as well as excluding many cells).

#### Barplots & contingency tables
We can examine size distribution of a single clustering with the function `plotBarplot`. By default, the cluster picked will be the primary cluster.

```{r plotBarplotRSEC}
plotBarplot(ceFluidigm,main=paste("Distribution of samples of",primaryClusterLabel(ceFluidigm)))
```


We can also compare two specific clusters with a simple barplot using `plotBarplot`. Here we compare the "makeConsensus" and the "mergeClusters" clusterings. 

```{r plotBarplot2}
plotBarplot(ceFluidigm,whichClusters=c("Published2" ,"Published1"))
```

Since "Published1" is a partition of "Published2", there is perfect subsetting within the clusters of "Published2".

A related plot is to plot a heatmap of the contingency table between two clusterings provided by `plotClustersTable`. This function plots a heatmap of the results of `tableClusters`, optionally converting them to proportions using `prop.table` function based on the parameter `margin`. Here, we'll set `margin=1`, meaning we will show each row (corresponding to a cluster of the  `mergeCluster` clustering), as a proportion -- i.e. the grey scale of the heatmap gives (in percentages) how the samples in that row's cluster are distributed across the clusters of the other clustering, `makeConsensus`

```{r plotClustersTable}
plotClustersTable(ceFluidigm,whichClusters=c("Published2" ,"Published1") , margin=1)
```

Again, since `Published1` clusters are all completely contained in `Published2`, this plot has less information than if we were comparing competing clusterings. For example, there is nothing on  the off-diagonal. But we can still see about how the smaller `Published1` clusters make up the `Published2`.

Another version of this plot is given by choosing `plotType="bubble"`, where now the size of the dot at each pair of clusters corresponds to the *absolute* size of the overlap, and the color scale is again the percentage overlap. 

```{r plotClustersTableBubble}
plotClustersTable(ceFluidigm,whichClusters=c("Published2" ,"Published1") , margin=1,plotType="bubble")
```

#### 2D plot of clusters 
We can plot a 2-dimensional representation of the data with PCA and color code the samples to get a sense of how the data cluster.

```{r plotReducedDims}
plotReducedDims(ceFluidigm)
```

We can also look at a higher number of dimensions (or different dimensions) by changing the parameter 'whichDims'.

```{r plotReducedDimsMany}
plotReducedDims(ceFluidigm,whichDims=c(1:4))
```

In this case we can see that higher dimensions show us a greater amount of separation between the clusters than in just 2 dimensions.


## Finding Features related to the clusters {#step4}

A common practice after determining a set of clusters is to perform differential gene expression analysis in order to find genes that show the greatest differences amongst the clusters. We would stress that this is purely an exploratory technique, and any p-values that result from this analysis are not valid, in the sense that they are likely to be inflated. This is because the same data was used to define the clusters and to perform differential expression analysis.

Since this is a common task, we provide the function `getBestFeatures` to perform various kinds of differential expression analysis between the clusters. A common F-statistic between groups can be chosen. However, we find that it is far more informative to do pairwise comparisons between clusters, or one cluster against all, in order to find genes that are specific to a particular cluster. An option for all of these choices is provided in the `getBestFeatures` function. 

The `getBestFeatures` function uses the DE analysis provided by the `limma` package [@Smyth:2004gh, @Ritchie:2015fa] or `edgeR` package [@Robinson:2010cw]. In addition, the `getBestFeatures` function provides an option to do use the "voom" correction in the `limma` package [@Law:2014ff] to account for the mean-variance relationship that is common in count data. The tests performed by `getBestFeatures` are specific contrasts between clustering groups; these contrasts can be retrieved without performing the tests using `clusterContrasts`, including in a format appropriate for the `MAST` algorithm.

As mentioned above, there are several types of tests that can be performed to identify features that are different between the clusters which we describe in the section entitled [Finding Features related to a Clustering](getBestFeatures). Here we simply perform all pairwise tests between the clusters. 

```{r getBestFeatures}
pairsAll<-getBestFeatures(ceFluidigm,contrastType="Pairs",p.value=0.05,
                          number=nrow(ceFluidigm),DEMethod="edgeR")
head(pairsAll)
```

### Heatmaps of features

We can visualize only these significantly different pair-wise features with a heatmap using the `plotHeatmap` function. 

First we need to identify the genes to plot for the heatmap. Our output `pairsAll` has a column `IndexInOriginal` that identifies the index of the genes in the original data matrix. 

However, notice that the same genes can be found in different contrasts, meaning our list of significant genes will not be unique:

```{r getBestFeatures_size}
# We have duplicates of some genes:
any(duplicated(pairsAll$Feature))
```

So some genes are significant for multiple of the tests. For our heatmap, we will descide to show only unique gene values so that they are not plotted multiple times in our heatmap. We will signify which genes to plot with the argument `clusterFeaturesData` (i.e. which data to use for the rows of the heatmap). 

```{r getBestFeatures_heatmap}
plotHeatmap(ceFluidigm, whichClusters=c("Published1","Published2"), clusterSamplesData="hclust",
            clusterFeaturesData=unique(pairsAll[,"IndexInOriginal"]),
            main="Heatmap of features w/ significant pairwise differences",
            breaks=.99)
```


#### Grouping the clusters

As we'll demonstrate, it can often be useful in visualization to find a hierarchy or clustering *of the clusters*. This is different from the hierarchical clustering above, because it forces the clusters to be kept together (e.g. if the clusters are created by a different algorithm than hiearchical clustering). The `makeDendrogram` function does this

```{r createDendrogram}
ceFluidigm<-makeDendrogram(ceFluidigm, whichCluster="Published1")
show(ceFluidigm)
```

We can visualize this relationship

```{r plotDendro}
plotDendrogram(ceFluidigm)
```

We can use this dendrogram for our heatmap instead:

```{r}
plotHeatmap(ceFluidigm, whichClusters=c("Published1","Published2"),clusterSamplesData="dendrogramValue",
            clusterFeaturesData=unique(pairsAll[,"IndexInOriginal"]),
            main="Heatmap of features w/ significant pairwise differences",
            breaks=.99)

```

Notice that the samples are now forced to respect the clustering provided in "Published1". The cells clustered into the `-1` cluster (i.e. not assigned) are clustered as an outgroup. This is a choice that is made when the dendrogram of the clusters was created (described below). These samples can also be mixed into the dendrogram at the time of creation (see [makeDendrogram](#makeDendrogram))

#### Grouping the contrasts

The above clumps all genes together regardless of which contrasts they were significant for. We can alternatively show a heatmap that will sort the genes by the different contrasts they correspond to using the `plotContrastHeatmap` function. The genes (rows) will be grouped by what contrast they are with. The option `nBlankLines` controls the space between the groups of genes from each contrast. We also give the argument `whichCluster="primary"` to indicate that the contrasts were created with the primary clustering (this means that the legend will put in the names of the clusters rather than their (internal) numeric id). 

```{r plotContrastHeatmap}
plotContrastHeatmap(ceFluidigm, signif=pairsAll,nBlankLines=40,whichCluster="primary")
```


# ClusterExperiment Objects {#ceobjects}

The object that we created is a `ClusterExperiment` object. The `ClusterExperiment` class is used by this package to keep the data and the clusterings together. It inherits from `SingleCellExperiment` class (which inherits from `SummarizedExperiment`) which means the data and `colData` and other information orginally in the `fluidigm` object are retained and can be accessed with the same functions as before. The `ClusterExperiment` object additionally stores clusterings and information about the clusterings along side the data. This helps keep everything together, and like the original `SummarizedExperiment` object we started with, allows for simple things like subsetting to a reduced set of subjects and being confident that the corresponding clusterings, colData, and so forth are similarly subset.

Typing the name at the control prompt results in a quick summary of the object. 

```{r show}
ceFluidigm
```

This summary tells us the total number of clusterings (`r nClusterings(ceFluidigm)`). It also gives information regarding the `primaryCluster` of the object. The `primaryCluster` is just one of the clusterings that has been chosen to be the "primary" clustering, meaning that by default various functions will turn to this clustering as the desired clustering to use. Often, if a function is not given a specific clustering (usually via an option `whichCluster` or `whichClusters`) the "primary" cluster is taken by default. 

There are also additional commands to access the clusterings and their related information (type `help("ClusterExperiment-methods")` for more).

The cluster assignments are stored in the `clusterMatrix` slot of `ceMatrix`, with samples on the rows and different clusterings on the columns. We saw that we can look at the cluster matrix and the primary cluster with the commands `clusterMatrix` and `primaryCluster`

```{r CEHelperCommands1}
head(clusterMatrix(ceFluidigm))
primaryCluster(ceFluidigm)
```


`clusterLabels` gives the column names of the `clusterMatrix`; 

```{r CEHelperCommands2}
clusterLabels(ceFluidigm)
```

The user can also change these labels:

```{r}
clusterLabels(ceFluidigm)<-c("Published 1","Published 2")
```

The information that was in the original `fluidigm` object has also been preserved, like `colData` that contains information on each sample.

```{r SECommandsOnCE}
colData(ceFluidigm)[,1:5]
```

Another important slot in the `ClusterExperiment` object is the `clusterLegend` slot. This consists of a list, one element per column (or clustering) of `clusterMatrix`, that gives colors and names to each cluster within a clustering. 

```{r CEClusterLengend}
length(clusterLegend(ceFluidigm))
clusterLegend(ceFluidigm)
```

We can see that each element of `clusterLegend` consists of a matrix, with number of rows equal to the number of clusters in the clustering. The columns store information about that cluster. `clusterIds` is the internal id (integer) used in `clusterMatrix` to identify the cluster, `name` is a name for the cluster, and `color` is a color for that cluster. `color` is used in plotting and visualizing the clusters, and `name` is an arbitrary character string for a cluster. They are automatically given default values when the `ClusterExperiment` object is created, but we will see under the description of visualization methods how the user might want to manipulate these for better plotting results. 

We can assign new values with a simple assignment operator, but we also provide the functions `renameClusters` and `recolorClusters` to help do this. Here we change the internal cluster names of "Published1" to be more consistent and clarify the substructure using `renameClusters`:

```{r CEClusterLengendAssign}
newName<-clusterLegend(ceFluidigm)[[1]][,"name"]
newName<-gsub("v","V",newName)
newName<-gsub("1","I",newName)
newName<-gsub("-I","NA",newName)
ceFluidigm<-renameClusters(ceFluidigm,whichCluster=1,value=newName)
print(ceFluidigm)
```

Note that if you choose to not use these functions and instead replace the whole matrix entry of the `clusterLegend` (e.g. `clusterLegend(ceFluidigm)[[1]]<- ...`) you should be careful not assign new values to `clusterIds` column, as the entries must exactly correspond to the internal ids of the clustering stored in the clustering matrix.

Another important way to organize clusterings is via "clusterType" values; this is intended when there are many clusterings stored in the object. To demonstrate this functionality, we are going to load an object that has a much larger number of clusterings based on a simple simulated data set (made via exploring many different clusterings with the `RSEC` package).

```{r loadSimData}
data(simCEData)
ceSimCount
```

We see that this object has `r nClusterings(ceSimCount)` clusterings stored. 

```{r clusterType}
clusterTypes(ceSimCount)
```

"clusterType" is a way of storing more global categories and unlike clusterLabels, are allowed to be shared across clusterings. Here we see most of the clusterings are labeled as "clusterMany"  (indicating they cam from a clustering step called "clusterMany" in `RSEC`), while one is marked as "User", which is the default category for any clustering added by the user. If we look at the 

```{r clusterType}
clusterTypes(ceFluidigm)
```

A use case would be creating different clusterings using the same algorithm, and giving all those the same clusterType, but different clusterLabels based on the different parameters. 

## Subsetting ClusterExperiment objects

Like `SummarizedExperiment` or `SingleCellExperiment` classes, standard subsetting of a `ClusterExeriment` object will result in a new `ClusterExperiment` object with all of the relevant parts of the data similarly subsetted. 


```{r basicSubsetting}
smallCe<-ceFluidigm[1:5,1:10]
smallCe

```

Notice from looking at the `clusterMatrix` below that the clustering results have been subset and that after subsetting, the internal cluster ids may change (because they are required to be consecutive). 

```{r matrixAfterSubset}
clusterMatrix(smallCe)
clusterMatrix(ceFluidigm)[1:10,]
```

However, the names (and colors) of each cluster should stay the same, which we can see by looking at the `clusterLegend` information

```{r lookAtSubset}
clusterLegend(smallCe)[["Published1"]]
clusterLegend(ceFluidigm)[["Published1"]]
```

Another useful type of subsetting can be to subset to only samples contained in a set of particular clusters within a clustering. This can be useful, for example, if you want to visualize the data in only those clusters. The function `subsetByCluster` allows you to do this, and it returns a new `ClusterExperiment` object with only those samples. The required input is to identify the values of the clusters you want to keep (by default matching to the clusters' names)
 
```{r subsampleByCluster}
subCe<-subsetByCluster(ceFluidigm,whichCluster="Published1",clusterValue=c("Ia","Ib","Ic"))
subCe
```

The object `subCe` now can be used for visualizing, or any other analysis. 

This kind of subsetting can also be useful in comparing clusterings, where the user might want to subset to all of the samples assigned to Cluster 1 in one clustering and then see what clusters that corresponds to in the other clusterings.

## Samples not assigned to a cluster (Negative Valued Cluster Assignments){#unassigned}
The different clusters are stored as consecutive integers, with '-1' and '-2' having special meaning. 

**Unassigned Samples (-1)** '-1' refers to samples that were not clustered by the clustering algorithm. In our example, we removed clusters that didn't meet specific size criterion, so they were assigned '-1'. 

**Missing from Clustering Run (-2)** '-2' is for samples that were not included in the original input to the clustering. This is useful if, for example, you cluster on a subset of the samples, and then want to store this clustering with the clusterings done on all the data. You can create a vector of clusterings that give '-2' to the samples not originally used and then add these clusterings to the `ceFluidigm` object manually with `addClusters`. 


You can also create a new object where all of the samples that are not assigned are removed with the `removeUnassigned` function. This is just a special case of `subsetByCluster` (above) for the special case of subsetting down to those samples assigned to any cluster.

## Dimensionality reduction and SingleCellExperiment Class {#dimReduce}

There are two varieties of dimensionality reduction supported in `clusterExperiment` package. 

1. reducing to a subset of features/genes based on the values of a filter statistic calculated for each gene or 
2. creation of a smaller number of new features that are functions of the original features, i.e. *not* a simple selection of existing variables, but rather create new variables to represent the data

For simplicity, we'll refer to the first as filtering of the data and second as a dimensionality reduction.  This is because in the first case, the reduced data set can be quickly recreated by subseting the original data so long as the per-gene statistics have been saved. This means only a single vector of the length of the number of genes needs to be stored for the first type of dimensionality reduction (filtering) while the second kind requires saving a matrix with a value for each observation for each new variable. 

`ClusterExperiment` inherits from the standard Bioconductor `SingleCellExperiment` class.  Briefly, the `SingleCellExperiment` class extends the `SummarizedExperiment` class to give a structure for saving the reduced matrices from dimensionality reductions as we described above.  They are saved in the slot `reducedDims`, which is a `SimpleList` of datasets that have the same number of observations as the original data in the assay slot, but reduced features (`?SingleCellExperiment`). This gives a unified way to save the results of applying a dimensionality reduction method of the second type; the package also gives helper functions to access them, etc. Multiple such dimensionality reductions can be stored since it is a list, and the user gives them names, e.g. "PCA" or "tSNE". 

`ClusterExperiment` uses the slot `reducedDims` to both save the results of dimensionality reductions if they are calculated and and also to reuse them if the necessary ones have already been created. This allows `clusterExperiment` to make use of any dimensionality reduction method so long as the user saves it in the appropriate slot in a `SingleCellExperiment` object. The package also provides some (limited) functionality to do the dimensionality reduction (i.e. PCA) and save the results of the PCA in the appropriate slot so that they will not need to be recalculated in the future. 

We also added in `clusterExperiment` package a similar procedure for storing the filtering statistics (i.e. statistics calculated on each gene). An example is the the variance across observations, calculated for every gene.  `clusterExperiment` when calculating statistics (like `var` or `mad`) will add the per-gene value of the statistic as a column of the `rowData` of the `ClusterExperiment` object. Similarly, if the user has already calculated a per-gene statistic and saved it as a column in the `rowData` slot, this user-defined statistic can be used for filtering. This means that the user is not limited to the built-in filtering functions provided in `clusterExperiment`.

The functions `makeReducedDims` and `makeFilterStats` calculate the dimensionality reduction and filtering statistics, respectively, provided by `clusterExperiment` and store them in the appropriate slot. To see the current list of built-in functions:

```{r buildInDimReduce}
listBuiltInReducedDims()
listBuiltInFilterStats()
```

# Visualizing the data {#visual}

In the quick start (above)[#visualsummary] we ran through many plots available for visualizing the data in conjunction with the clusterings. In this section we do not go through all of these plots, but just highlight the details of some plots which are more complicated. 

## Cluster Alignment plot with `plotClusters` {#plotClusters}

We demonstrated during the quick start that we can visualize the alignment of multiple clusterings via a Cluster Alignment plot implemented in `plotClusters` command. 


Here is our basic call to `plotClusters`:

```{r plotClusterEx1_redo}
par(mar=plotCMar)
plotClusters(ceFluidigm,whichClusters="all", 
             axisLine=-1)
```

We show it now on our object with more clusterings:

```{r plotClustersSim}
par(mar=plotCMar)
plotClusters(ceSimCount, whichClusters="all")
```

We see a lot of commonality between our clusterings, except for the last ("cluster1") which was a randomly generated assignment which we don't expect to have any relation to the data!


We can get very different plots depending on how we order the clusterings, and what clusterings are included. The argument `whichClusters` allows the user to choose different clusterings or provide an explicit ordering of the clusterings. Below we choose to order them first based on "cluster1" (the random assignments); notice the user can specify numeric indices corresponding to the columns of `clusterMatrix` to provide the order of the clusters in the plot.

```{r plotClustersSim}
par(mar=plotCMar)
plotClusters(ceSimCount, whichClusters=c(13,1:12))
```

`whichClusters` can take either a single character value, or a vector of either characters  or indices. If `whichClusters` matches  "all", then all the clusterings are plotted. 

If `whichClusters` is a character that is not one of these designated values, the entries should match one of the "clusterLabel" values or "clusterType" values. Here's an example matching to the clusterLabels of our object

```{r plotClustersSim}
par(mar=plotCMar)
plotClusters(ceSimCount, whichClusters=c( "k=NA,nReducedDims=10,findBestK=TRUE,distFunction=K", "k=NA,nReducedDims=5,findBestK=TRUE,distFunction=K", 
"cluster1"  ))
```

We could show only those with the `clusterType="clusterMany"` (removing that randomly created clustering, "cluster1")

```{r plotClusterEx1_newOrder}
par(mar=plotCMar)
plotClusters(ce,whichClusters="clusterMany",
               main="Only Clusters from clusterMany",axisLine=-1)
```


We can also add to our plot (categorical) information on each of our subjects from the `colData` of our SummarizedExperiment object (which is also retained in our ClusterExperiment object). This can be helpful to see if the clusters correspond to other features of the samples, such as sample batches. Here the info in the colData is again arbitrary randomly assigned values.

```{r plotClusterEx1_addData}
par(mar=plotCMar)
plotClusters(ceSimCount,whichClusters="all", colData=c("A","B","C"), 
               main="Clusters plus other data",axisLine=-1)
```

### Manipulations of colors {#plotClustersAlign}

In this section we will talk about a number of related ways to manipulate the colors assigned to clusters in conjunction with the `plotClusters` command.

We will turn off the plotting of the cluster labels to make the plot less cluttered using the option `clusterLabels=FALSE`.


#### Saving Assignment of colors from `plotClusters`

`plotClusters` invisibly returns a `ClusterExperiment` object. In our earlier calls to `plotCluster`, this would be the same as the input object and so there is no reason to save it. However, the alignment and color assignments created by `plotClusters` can be requested to be saved *into* the appropriate slots of the `ClusterExperiment` object in order to save the color and alignments of samples. This is done via the `resetNames`, `resetColors` and `resetOrderSamples` arguments. If any of these are set to TRUE, then the object returned will be different than those of the input. 

Specifically, if `resetColors=TRUE` the `colorLegend` of the returned object will be changed so that the colors assigned to each cluster will be as were shown in the plot (and indeed this is done automatically by `mergeClusters` so that the `makeConsensus` and `mergeClusters` steps will have aligned color assignments). Similarly, if `resetNames=TRUE` the *names* of the clusters will be changed to be integer values, but now those integers will be aligned to try to be the same across clusters (and therefore will not be consecutive integers, which is why these are saved as *names* for the clusters and not the internal `clusterIds`). If `resetOrderSamples=TRUE`, then the order of the samples shown in the plot will be similarly saved in the slot `orderSamples`. 

As an example, we will make a call to `plotClusters`, but now ask to reset everything to match this clusterAlignment. 

First let's look at what the object's default colors are for the first two clusterings, accessed by `clusterLegend` function:

```{r plotClusterEx1_origColors}
clusterLegend(ceSimCount)[1:2]
```

The `plotClusterLegend` creates a quick legend plot of this information for a single clustering:

```{r plotClusterLegend_before,out.width="300px",out.height="300px"}
plotClusterLegend(ceSimCount,whichCluster=1)
```

Now, we'll run `plotClusters` and save the new colors. We'll save this as a different object so that this is not a permanent change for the rest of the vignette, though in practice we would usually overwrite the existing `ce` to save memory on our computer and not have many versions floating around. 

```{r plotClusterEx1_setColors}
ce_temp<-plotClusters(ceSimCount,whichClusters="clusterMany",
               main="Cluster Alignment of clusterMany Clusters",clusterLabels=FALSE, axisLine=-1, resetNames=TRUE,resetColors=TRUE,resetOrderSamples=TRUE)
```

Now, the `clusterLegend` slot of the object no longer has the default color/name assignments, but it has names and colors that match across the clusters. Notice, that this means the prefix "m" or "c" that was previously given to distinguish the `makeConsensus` result from the `mergeClusters` result is now gone (the user could manually add them by changing the values in the clusterLegend). Instead, there are names that "match up" the clusters across the different clusterings. 

```{r plotClusterEx1_newColors}
clusterLegend(ce_temp)[1:2]
```


#### Manual Assignment of colors

A similar setting can be that we have colors we want to manually set for a particular cluster, but we want to have the other clusterings get aligned to the colors of that clustering. We can use `plotClusters` to assign colors to the other clusterings so that the other clusterings inherit the colors of the cluster of interest. 

Let's manually set the colors for the "mergeClusters" clustering. We'll again create a (new)  `ce_temp` object so again we don't overwrite the previous colors for the rest of the vignette. Again, the color information is accessed with the `clusterLegend` command:

```{r plotClusterEx1_clusterLegend}
ce_temp<-ceSimCount
clusterLegend(ce_temp)[[1]]
```

We will just assign new colors to the `color` column with the `recolorClusters` function. We can also give them new names too with `renameClusters`.

```{r plotClusterEx1_assignColors}
newColors<-c("white","grey","blue","green","cyan","purple")
newNames<-c("Not assigned","Not included","Cluster1","Cluster2","Cluster3","Cluster4")
#note we make sure they are assigned to the right cluster Ids by giving the 
#clusterIds as names to the new vectors
names(newColors)<-names(newNames)<-clusterLegend(ce_temp)[["mergeClusters"]][,"name"]
ce_temp<-renameClusters(ce_temp,whichCluster=1,value=newNames)
ce_temp<-recolorClusters(ce_temp,whichCluster=1,value=newColors)
```

We use the `plotClusterLegend` to check that we assigned them as we expected:

```{r plotClusterLegend,out.width="300px",out.height="300px"}
plotClusterLegend(ce_temp,whichCluster=1)
```

Now we will run the `plotClusters` alignment plot, but we will direct the alignment to use the cluster colors we just gave for the "mergeClusters" cluster. We do this by using the argument `existingColors="firstOnly"` 

```{r plotClusterEx1_firstOnlyNoSave}
plotClusters(ce_temp,whichClusters="clusterMany", clusterLabels=FALSE,
               main="Clusters from clusterMany, different order",axisLine=-1,existingColors="firstOnly")
```

This just created the visualization. We can also save the results of this as we did before with `resetColors=TRUE`, so that now all of our future clusters make use of this color information. We won't reset the names, however. Note we can avoid making the plot again with the argument `plot=FALSE`.

```{r plotClusterEx1_firstOnly}
ce_temp<-plotClusters(ce_temp,whichClusters="clusterMany", resetColors=TRUE,
               main="Clusters from clusterMany, different order",axisLine=-1, clusterLabels=FALSE, existingColors="firstOnly",plot=FALSE)
```

#### Using only the assigned colors

Once we start manually changing the colors, we will sometimes want to align our clusters, but *use the existing cluster colors* that are saved in the object. We can force `plotClusters` to use all the existing color assignments, rather than create its own, with the argument `existingColors="all"`. This makes particular sense if you want to have continuity between plots -- i.e. be sure that a particular cluster always has a certain color -- but would like to do different variations of plotClusters to get a sense of how similar the clusters are.

For example, we set the colors above based on the cluster alignment produced in the above `plotClusters` where the clusterings were ordered according to the workflow and making use of the colors we manually assigned to "mergeClusters". But now we want to plot only the clusters from `clusterMany`, yet keep the same colors that we just saved so we can compare them. We do this by setting the argument `existingColors="all"`, meaning use all of the existing colors.

```{r plotClusterEx1_forceColors,fig.width=18,fig.height=9}
par(mfrow=c(1,2))
plotClusters(ce_temp, 
             whichClusters=1:12, existingColors="all", clusterLabels=FALSE,
             main="clusterMany Clusters, use existing colors",axisLine=-1)

plotClusters(ce_temp, 
             existingColors="all", whichClusters=12:1, clusterLabels=FALSE,
             main="clusterMany Clusters, different order",
             axisLine=-1)
```

This is difficult to see what happened, because I supressed the cluster labels. But if I plot the clusterLabels they are too long. I'm going to make short cluster labels:

```{r}
clustLabs<-clusterLabels(ce_temp)
clustLabs<-sapply(strsplit(clustLabs,","),function(x){if(length(x)>1) paste(sapply(strsplit(x,"="),.subset2,2),collapse=",") else x})
clustLabs
```

I could replace them in my object `ce_temp` but instead I'm going to replace them on the fly for the plot

```{r plotClusterEx1_forceColors,fig.width=18,fig.height=9}
par(mfrow=c(1,2))
plotClusters(ce_temp, 
             whichClusters=1:12, existingColors="all", clusterLabels=clustLabs[1:12],
             main="clusterMany Clusters, use existing colors",axisLine=-1)

plotClusters(ce_temp, 
             existingColors="all", whichClusters=12:1, clusterLabels=clustLabs[12:1],
             main="clusterMany Clusters, different order",
             axisLine=-1)
```
Notice I have to be careful they are in the same order as I plot them in the plot. 

We see that while the order of the samples has changed (because I have a different set of clusters to align) the *colors* assigned to each cluster have stayed the same, so I can more easily compare the plots.

Note that the use of `existingColors="firstOnly"` and `existingColors="all"` will not give the same color assignments, *even if the colors have been previously aligned to be the same* unless its the exact same set of clusterings in the same order. This is because with each set of ordered clusterings, the realignment between clusters changes and so the assignment of colors changes. Here we will make a ClusterAlignment plot for each of these three options of the argument to demonstrate the difference.

```{r plotClusterEx1_compareForceColors,fig.width=18,fig.height=18}
par(mfrow=c(2,2))
plotClusters(ce_temp,  
             existingColors="all", whichClusters=12:1, clusterLabels=FALSE,
             main="clusterMany Clusters, use existing colors",
             axisLine=-1)
plotClusters(ce_temp, 
               existingColors="firstOnly", whichClusters=12:1, clusterLabels=FALSE,
               main="clusterMany Clusters, use existing of first row only",
               axisLine=-1)
plotClusters(ce_temp, 
            existingColors="ignore", whichClusters=12:1, clusterLabels=FALSE,
            main="clusterMany Clusters, default\n(ignoring assigned colors)",
            axisLine=-1)
```

#### Choosing a different set of colors

`plotClusters` uses the set of colors defined in the variable `massivePalette`. This is a set of `r length(massivePalette)` colors. `plotClusters` draws from this set of colors sequentially as it goes down the clusterings each time it needs a new color. This is obviously a very large list of colors; the reason for such a long list is that `plotClusters` will error out if there are not enough colors, so we want to have a large list. If we are running RSEC with many clusterings, and each clustering has many clusters, you can quickly run through many.  The first `r length(bigPalette)` colors are a smaller subset of colors saved as a variable `bigPalette`, and these have been hand-chosen so that the colors are vibrant and not too similar to each other; the order has also been chosen so that more similar colors are not next to each other. This are the colors that are most frequently seen. `massivePalette` consists of these colors, plus all of the non-grey colors in `colors()` that are not already contained in `bigPalette`

We can examine the colors in `bigPalette` with the command `showPalette`:

```{r showPalette}
showPalette()
```

This plot shows us both the name of the color (on the top) and the index of the color in `bigPalette`. 

We can show a smaller subset or give an arbitrary set of colors to show with `showPalette`

```{r showPaletteOptions}
showPalette(which=1:10)
showPalette(palette())
```

We can even show the entire `massivePalette` (notice for list of colors > 100 in length, the index is no longer plotted)

```{r showPaletteMassive}
showPalette(massivePalette,cex=0.5)
```


We can use this information to help change our color choices. For example, suppose I want the unassigned samples to be given the color black instead of white. Then I would like to not use the black in `bigPalette` to assign to a clustering. I will use the `colPalette` argument to give a new set of colors that does not include "black". And I will set the unassigned samples using the option `unassignedColor="black"` (there is a similar argument `missingColor` to set the color assigned to those clusters with the identification of "-2", meaning they were not included in the clustering at all).

```{r removeBlack}
plotClusters(ceSimCount,whichClusters="clusterMany", unassignedColor="black",
	colPalette=bigPalette[-grep("black",bigPalette)],
               main="Setting unassigned color",axisLine=-1)

```

## Heatmap including the clusters with `plotHeatmap` {#plotHeatmap}
There is also a default heatmap command for a `ClusterExperiment` object that we used in the Quick Start. By default it clusters on the most variable features (after transforming the data) and shows the `primaryCluster` alongside the data. The `primaryCluster`, now that we've run the workflow, has been set as that from the last mergeClusters step. 

```{r plotHeatmap_Ex1}
par(mfrow=c(1,1))
par(mar=defaultMar)
plotHeatmap(ceFluidigm,main="Heatmap with primary cluster")
```

The `plotHeatmap` command has numerous options, in addition to those of `aheatmap`. `plotHeatmap` mainly provides additional functionality in the following areas: 

* Easy inclusion of clustering information or sample information, based on the ClusterExperiment object.
* Additional methods for ordering/clustering the samples that makes use of the clustering information.
* Use of separate input data for clustering and for visualization.
* Setting the breaks for better visualization

### Displaying clustering or sample information

Like `plotClusters`, `plotHeatmap` has a `whichClusters` option that behaves similarly to that of `plotClusters`.  In addition to the options "all"  that we saw with `plotClusters`, `plotHeatmap` also takes the option "none"" (no clusters shown) and "primary" (only the primaryCluster). The user can also request a subset of the clusters by giving specific indices to `whichClusters` like in `plotClusters`.

Here we create a heatmap that shows both the clusters. 

```{r plotHeatmap_Ex1.1}
plotHeatmap(ceFluidigm,whichClusters="all")
```

Here's our simulated data

```{r plotHeatmap_Ex1.1}
plotHeatmap(ceSimCount,whichClusters="clusterMany", annLegend=FALSE)
```

Notice we also passed the option 'annLegend=FALSE' to the underlying `aheatmap` command (with many clusterings shown, it is often not useful to have a legend for all the clusters because the legend doesn't fit on the page!). The many detailed commands of `aheatmap` that are not set internally by `plotHeatmap` can be passed along as well. 

Like `plotClusters`, `plotHeatmap` takes an argument `colData`, which refers to columns of the `colData` of that object and can be included.  

### Additional options for clustering/ordering samples

The previous plot used the dendrogram we made of the clusters within "Published1". We can make other options

We can choose to not cluster the samples, but order the samples by cluster. This time we'll just show the primary cluster (the `mergeCluster` result) by setting `whichClusters="primaryCluster"`:

```{r plotHeatmap_primaryCluster}
plotHeatmap(ceFluidigm,clusterSamplesData="primaryCluster",
            whichClusters="Published1",
            main="Heatmap with clusterMany",annLegend=FALSE)
```

Our default, based on the dendrogram we made, was an improvement upon this, since it clustered the clusters into a dendrogram so that the most similar clusters will be near each other. This is done via the option `clusterSamplesData="dendrogramValue"`. This will be the default if there is a dendrogram stored with our object, which there is:

```{r}
show(ceFluidigm)
```

We can also get a standard hierarchical clustering with `clusterSamplesData="hclust"`. We can also show values from our `colData`. 

```{r plotHeatmap_dendro}
plotHeatmap(ceFluidigm,clusterSamplesData="hclust",
            whichClusters=c("Published2","Published1"),
            main="Heatmap standard hierarchical clustering",
            colData=c("Biological_Condition"),annLegend=TRUE)
```

### Using separate input data for clustering and for visualization

While count data is a common type of data, it is also common that the input data in the SummarizedExperiment object might be normalized data from a normalization package such as `RUVSeq`. In this case, the clustering and all numerical calculations should be done on the normalized data (which may or may not need a log transform). However, these normalized data might not be on a logical count scale (for example, in `RUVSeq`, the normalize data are residuals after subtracting out gene-specific batch effects). 

In this case, it can be convenient to have the *visualization* of the data (i.e. the color scale), be based on a count scale that is interpretable, even while the clustering is done based on the normalized data. This is possible by giving a new matrix of values to the argument `visualizeData`. In this case, the color scale (and clustering of the features) is based on the input `visualizeData` matrix, but all clustering of the samples is done on the internal data in the `ClusterExperiment` object. 

### Setting the breaks

Usually, the breaks that determine the colors of the heatmap are evenly spaced across the range of the data in the entire matrix. When there are a few outlier samples or genes, they can dominate the color and make it impossible to visualize the bulk of the data. 

For this reason, the argument `breaks` in `plotHeatmap` allows for a value between 0 and 1, to indicate that the range of colors should be chosen as equally spaced between certain quantiles of the data. For example, if `breaks=0.99`, the range of equally spaced breaks will stop at the top 0.99 quantile of the data and anything above that value gets assigned the single extreme color. If there is negative data in the matrix, then it also will use the lower quantile of the data to stop the range of equally spaced breaks (see `?setBreaks`)

Here 


```{r plotHeatmap_break99}
plotHeatmap(ceFluidigm,clusterSamplesData="primaryCluster",
            whichClusters="primaryCluster", breaks=0.99,
            main="Heatmap with clusterMany, breaks=0.99",annLegend=FALSE)
```

```{r plotHeatmap_break95}
plotHeatmap(ceFluidigm,clusterSamplesData="primaryCluster",
            whichClusters="primaryCluster", breaks=0.95,
            main="Heatmap with clusterMany, breaks=0.95",annLegend=FALSE)
```

The function `setBreaks` which is called internally by `plotHeatmap`  is also a stand-alone function that the user can call directly to have greater flexibility in getting breaks for the heatmap. For example it allows the user to specify that the breaks should be symmetric around 0. We also provide some default color spectrum that can be better for different settings or symmetric data around 0 -- see `?showHeatmapPalettes`


## Dendrogram of clusters with `plotDendrogram`{#plotDendrogram}

We saw above that we can quickly see the hierarchies of the clusters using the `plotDendrogram` function. 

```{r plotDendro_redoBasic}
plotDendrogram(ceFluidigm)
```

This shows us the dendrogram stored in the object (created from the clustering resulting from the `makeConsensus` step). The relative sizes of each cluster are shown, along with a legend of the clusters. 

### Changing the leaf and plot type 
Alternatively, we can just make a simpler plot with `plotDendrogram` by use of the `leafType` and `plotType` arguments. The above plot uses the defaults: `leafType="samples"`, meaning plot the individual samples at the leaves of the tree, and `plotType="colorblock"` meaning to display the leaves' values as blocks of colors. Here we change these options


```{r plotDendro_Types}
par(mfrow=c(1,2))
plotDendrogram(ceFluidigm,leafType="clusters",plotType="colorblock")
plotDendrogram(ceFluidigm,leafType="clusters",plotType="name")
```

If we have a small number of samples, we can even choose `leafType="samples"` and `plotType="name"` to show the names of the *individual samples*, but usually we have too many samples (i.e. cells) to do this.

### Changing the information plotted with dendrogram

#### Additional clusters 

If the option is `plotType="colorblock"` and `leafType="samples"` (i.e. the default) we can also vary the sample information that is plotted with the dendrogram, much like with `plotHeatmap`. In particular, we can show multiple clusters using the option `whichClusters`.

```{r plotDendro_MultiClusters}
par(mar=plotDMar)
plotDendrogram(ceFluidigm,whichClusters=c("all"))
```


#### Sample data 
We can also include data stored in `colData` slot of the object, so long as it is discrete (i.e. a factor or character vector).

```{r plotDendro_colData}
plotDendrogram(ceFluidigm,whichClusters="all",colData=c("Biological_Condition"))
```


#### Node information

We can pass options to `plot.phylo` to change the output of the dendrogram. For example, we can print the node names or colors   For example, to see the node names, we can set `show.node.label = TRUE` (we have to turn off plotting the merge information, since the merge information is plotted as node labels too.)

```{r plotDendro_NodeNames}
par(mar=plotDMar)
plotDendrogram(ce,whichClusters="all",show.node.label=TRUE)
```

We can also give the nodes colors (useful for linking up with colors from `plotContrastHeatmap` if using hierarchical contrasts, see below). Here we give own argument `nodeColors` (not that from `plot.phylo`) to make it easier; the argument takes a vector of colors, where the names of the vectors match the node names. Notice, we can plot the merge information with node colors.

```{r plotDendro_NodeColors}
nodeNames<-paste("NodeId",1:6,sep="")
nodeColors<-massivePalette[1:length(nodeNames)]
names(nodeColors)<-nodeNames
par(mar=plotDMar)
plotDendrogram(ceFluidigm,whichClusters="all",nodeColors=nodeColors)
```

# How the dendrogram is saved {#dendrostructure}

The resulting dendrograms (one for just the cluster hierarchy and one that expands the cluster hierarchy to include the samples) are saved in the object. They are each saved as a `phylo4d` class from the package `phylobase` (which uses the basic format of the S3 class `phylo` in the `ape` package, but is a S4 class with some useful helpers). 

They can be accessed with the functions `clusterDendrogram` and `sampleDendrogram`. 

```{r printClusterDendrogram}
clusterDendrogram(ceFluidigm)
head(sampleDendrogram(ceFluidigm))
```

Just like the clusters, the nodes have permanent non-changing names (stored in the `NodeId` column). The dendrograms also store information on how to match the dendrogram to the clusters. To see more about the information saved in these dendrograms, see `?clusterDendrogram`. 

Generally, these dendrograms will not need to be directly manipulated by the user. But if desired, the user can explore these objects using the functions in `phylobase`.

```{r showPhylobase}
library(phylobase)
nodeLabels(clusterDendrogram(ceFluidigm))
descendants(clusterDendrogram(ceFluidigm),node="NodeId3")
```

The main reason to really ever work with these dendrograms directly is  to link it back with the  (feature extraction results)[#Dendrocontrasts]  (or merge results from `RSEC` package). In particular, one feature of the cluster dendrogram can be set by the user is the labels for the internal nodes of the cluster hierarchy. Because of this there is a function `nodeLabels` that can be called *directly on the `ClusterExperiment` object* to see and update these values. Unlike our previous code, where we extracted the dendrogram and then used the functions in `phylobase` to look at it, these functions will update the actual dendrograms inside the object.

We'll demonstrate this by giving the nodes new names that are the letters A-Z. The main trick in creating new node labels, is that it is *required* that the vector of new names have names that match the internal node ids (the `NodeId` column). These are the default names of the node, we can use the default names (given by `nodeLabels`) to grab them. 

```{r changeNodeLabels}
newNodeLabels<-LETTERS[1:nNodes(ceFluidigm)]
names(newNodeLabels)<-nodeLabels(ceFluidigm)
nodeLabels(ceFluidigm)<-newNodeLabels
```




# Finding Features related to a Clustering {#getBestFeatures}

The function `getBestFeatures` finds features in the data that are strongly differentiated between the clusters of a given clustering. Finding the best features is generally the last step in the workflow, once a final clustering has been decided upon.

The function `getBestFeatures` calls either `limma` [@Smyth:2004gh, @Ritchie:2015fa] or `edgeR` [@Robinson:2010cw] on input data to determine the gene features most associated with a particular clustering.  `getBestFeatures` picks the `primaryCluster` of a `ClusterExperiment` object as the clustering to use to find features. The primaryCluster can of course be changed by setting `primaryClusterIndex` to point to a different clustering. 


The basic implementation of these functions fits a linear model per feature and tests for the significance of parameters of that linear model, with appropriate adjustment to a negative binomial model in the case of `edgeR`. The main contribution of `getBestFeatures` is to interface with `limma`  or `edgeR` so as to pick appropriate parameters or tests for comparing clusters. Naturally, `getBestFeatures` also seamlessly works with `ClusterExperiment` objects to minimize the burden on the user. The output is in the form of `topTable` or `topTags` in `limma` or `edgeR` respectively, i.e. a data.frame giving the relevant features, the p-value, etc. 

Note that `getBestFeatures` will remove all samples unassigned to a cluster (i.e. `-1` or `-2`), so that these samples will not in anyway influence the DE analysis (see [#unassigned] for more information about unassigned samples). 

## Types of Significance Tests (Contrasts)

There are several choices of what is the most appropriate test to determine whether a feature is differentially expressed across the clusterings. All of these methods first fit a linear model where the clusters categories of the clustering is the explanatory factor in the model (samples with -1 or -2 are ignored). The methods differ only in what significance tests they then perform, which is controlled by the argument `type`. By default,  `getBestFeatures` finds significant genes based on a F-test between the clusters (`type="F"`). This is a very standard test to compare clusters, which is why it is the default, however it may not be the one that gives the best or most specific results. Indeed, in our "Quick Start", we did not use the $F$ test, but rather all pair-wise comparisons between the clusters. 

The $F$ test is a test for whether there are *any* differences in expression between the clusters for a feature. Three other options are available that try to detect instead specific kinds of differences between clusters that might be of greater interest. Specifically, these differences are encoded as "contrasts", meaning specific types of differences between the means of clusters. 

Note that for all of these contrasts, we are making use of all of the data, not just the samples in the particular cluster pairs being compared. This means the variance is estimated with all the samples. Indeed, the same linear model is being used for all of these comparisons. 

### All Pairwise
The option `type="Pairs"`, which we saw earlier, performs all pair-wise tests between the clusters for each feature, testing for each pair of clusters whether the mean of the feature is different between the two clusters. Here is the example from above using all pairwise comparisons on the results of rsec:

```{r getBestFeatures_onlyTopPairs}
pairsAllTop<-getBestFeatures(ceFluidigm,contrastType="Pairs",DEMethod="edgeR",p.value=0.05)
dim(pairsAllTop)
head(pairsAllTop)
```

Notice that compared to the quick start guide, we didn't set the parameter `number` which is passed to topTable, so we can get out *at most* 10 significant features for each contrast/comparison (because the default value of `number` in `topTable` is 10). Similarly, if we didn't set a value for `p.value`, `topTable` would return the top `number` genes per contrast, regardless of whether they were all significant or not. These are the defaults of `topTable`, which we purposefully do not modify, but we urge the user to read the documentation of `topTable` carefully to understand what is being asked for. In the QuickStart, we set `number=NROW(ceFluidigm)` to make sure we got *all* significant genes.

In addition to the columns provided by `topTable`, the column "Contrast" tells us what pairwise contrast the result is from. "Cl01-Cl02" means a comparison of cluster 1 and cluster 2 (note that these refer to the cluster ids, not any name they might have). The column "IndexInOriginal" gives the index of the gene to the original input data matrix, namely `assay(ce)`. The other columns are given by `topTable` (with the column "Feature" renamed -- it is usually "ProbeID" in `limma`).  

### One Against All
The choice `type="OneAgainsAll"` performs a comparison of a cluster against the mean of all of the other clusters. 

```{r getBestFeatures_oneAgainstAll}
best1vsAll<-getBestFeatures(ceFluidigm,contrastType="OneAgainstAll",DEMethod="edgeR",p.value=0.05,number=NROW(ceFluidigm))
head(best1vsAll)
```

Notice that now there is both a "Contrast" and a "ContrastName" column, unlike with the pairs comparison. Like before, "Contrast" gives an explicit definition of what is the comparisons, in the form of "(Cl02+Cl03+Cl04+Cl05+Cl06)/5-Cl01", meaning the mean of the means of clusters 2-6 is compared to the mean of cluster1. Note that the contrasts here are always written in terms of the internal (numeric) cluster id, with an "Cl" in front of the number and a '0' to make the number 2 digits. "ContrastName" interprets this into a more usable name, namely that this contrast can be easily identified as a test of "Cl01" (cluster 1). 

We can plot the contrasts with a heatmap for these results. Here we notice that the color next to the gene group matches the cluster that the contrast matches. 

```{r getBestFeatures_oneHeatmap}
plotContrastHeatmap(ceFluidigm,signifTable=best1vsAll,nBlankLines=10, whichCluster="primary")
```

### Dendrogram {#Dendrocontrasts}

The option `type="Dendro"` is more complex; it assumes that there is a hierarchy of the clusters (created by `makeDendrogram` and stored in the `ClusterExperiment` object).  Then for each *node* of the dendrogram, `getBestFeatures` defines a contrast or comparison of the mean expression between the daughter nodes. 

```{r getBestFeatures_dendro}
bestDendro<-getBestFeatures(ceFluidigm,contrastType="Dendro",DEMethod="edgeR",p.value=0.05,number=NROW(ceFluidigm))
head(bestDendro)
```

Again, there is both a "ContrastName" and "Contrast" column, as well as a "InternalName" column. The "Contrast" column identifies which clusters ids were on each side of the node (and hence commpared). "InternalName" is the *internal* name of the node, determined internally during `makeDendrogram`, while "ContrastName" is the name of the node, which might have been set by the user (for information about node names, and how to set the node names see on the (internal structure of the dendrogram](#dendrostructure))

```{r dendroContrastLevels}
levels((bestDendro)$Contrast)
```

We can look at the results again with `plotContrastHeatmap`. 

```{r getBestFeatures_dendroHeatmap}
plotContrastHeatmap(ceFluidigm,signifTable=bestDendro,nBlankLines=10)
```

We can plot the dendrogram to help make sense of which contrasts go with which nodes and choose to show the node names with `show.node.label=TRUE` (plotDendrogram calls `plot.phylo` from the `ape` package and can take as imput those arguments like `show.node.label`).

```{r dendroWithNodeNames}
plotDendrogram(ceFluidigm,show.node.label=TRUE,whichClusters=c("all"),leaf="samples",plotType="colorblock")
```


## DE Analysis for count and other RNASeq data

The `getBestFeatures` method for `ClusterExperiment` objects has an argument `DEMethod` to determine what kind of DE method should be run. The options are `limma`, `limma-voom` and `edgeR`. The last two options assume that `assay(x)` are counts. 


* **`limma`** In this case, the data is assumed to be continous and roughly normal and the `limma` DE method is performed on `transformData(x)`, i.e. the data after transformation of the data with the transformation stored in the `ClusterExperiment` object.  

* **`limma-voom`** refers to calling limma with the `voom`[@Law:2014ff] correction which uses the normal linear model of `limma` but deals with the mean-variance relationship that is found with count data. This means that the differential expression analysis is done on $log_2(x+0.5)$. This is *regardless of what transformation is stored in the `ClusterExperiment` object*! The `voom` call within `getBestFeatures` sets `normalize.method = "none"` in the call to `voom`.  Unlike edgeR or DESeq, the voom correction does not explicitly require a count matrix, and therefore it has been proposed that it can be used on FPKM or TPM entries, or data normalized via RUV. However, the authors of the package do not recommend using voom on anything other than counts, see e.g. [this discussion](https://support.bioconductor.org/p/45749/). 

* **`edgeR`** Performs a likelihood-ratio test (`glmLRT` function in `edgeR` [@Robinson:2010cw]) based on a negative binomial distribution and a empirical bayes estimation of the dispersion. 

* **`edgeR` with zero-inflated weights** Weights can be provided to `getBestFeatures`, in which case the LRT is performed using the function `glmWeightedF` in the `zinbwave` package following the work of [@VandenBerge2018]. The best way to do this is to save the weights in an assay entitled `weights`. Here is an example of mock code:

```{r exampleCode,eval=FALSE}
assay(ceFluidigm,"weights")<- myweights
```

If the initial `SummarizedExperiment` object is set up this way, then the functions `getBestFeatures`, `mergeClusters` , and `RSEC` will all automatically look for such an assay in order to use these weights, if `DEMethod="edgeR"`. Indeed for `RSEC` this is the *only* way to get weights used -- unlike `getBestFeatures` and `mergeClusters`, `RSEC` doesn't give a way for the user to make choices about the weights (this is to simplify the number of parameters).  For `getBestFeatures` and `mergeClusters` you can manually set the argument `weights` to be `NULL` to force the functions to NOT use the weights stored here  (and the standard edgeR routine is followed instead) or alternatively set `weights` to be another assay name or even a matrix of weights.

**Normalization Factors** Both `limma-voom` and `edgeR` calls first set up a `DGEList` object which is then given to either the `voom` function in the `limma` package or the `estimateDisp` function of `edgeR`. The argument `counts` to the `DGEList` function is given by the data in the assay, but you can pass other arguments to the call to `DGEList` by giving them in a list format to the argument `dgeArgs` of `getBestFeatures` (or the other functions that call `getBestFeatures`). In particular, you can pass arguments such as `norm.factors` or `lib.size` to specify normalization factors, which will then be used by the `voom`/`edgeR` commands. 

## Piping into other DE routines

Ultimately, for many settings, the user may prefer to use other techniques for differential expression analysis or have more control over certain aspects of it. The function `clusterContrasts` may be called by the user to get the contrasts that are defined within `getBestFeatures` (e.g. dendrogram contrasts or pairwise contrasts). These contrasts, which are in the format needed for `limma` or `edgeR` can be piped into programs that allow for contrasts in their linear models for mRNA-Seq; they can also be chosen to be returned in the formated needed by MAST [@Finak:2015id] for single-cell sequencing by settting `outputType="MAST"`. 

Similarly, more complicated normalizations, like RUV [@GagnonBartsch:2011jv], adjust each gene individually for unwanted batch or other variation within the linear model. In this case, a matrix $W$ that describes this variation should be included in the linear model. Again, this can be done in other programs, using the contrasts provided by `clusterContrasts` in combination with $W$. 


## Multiple Testing adjustments

The user should be careful about questions of multiple comparisons when so many  contrasts are being performed on each feature; the default is to correct across all of these tests (see the help of `getBestFeatures` and the argument `contrastAdj` for more). As noted in the introduction, p-values created in this way are reusing the data (since the data was also used for creating the clusters) and hence should not be considered valid p-values regardless.


As mentioned, `getBestFeatures` accepts arguments to `limma`'s function `topTable` (or `topTags` for `edgeR`) to decide which genes should be returned (and in what order). In particular, we can set an adjusted p-value cutoff for each contrast, and set `number` to control the number of genes returned *for each contrast*. By setting `number` to be the length of all genes, and `p.value=0.05`, we can return all genes for each contrast that have adjusted p-values less than 0.05. All of the arguments to `topTable` regarding what results are returned and in what order can be given by the user at the call to `getBestFeatures`.



# Working with other `assays()` {#multipleAssays}

By default, all the other user-facing functions in `clusterExperiment` will use the first `assay` if applied to `SummarizedExperiment`-like objects (including `SingleCellExperiment` and `ClusterExperiment`).

However, it is often the case that one needs to use the data saved in a different `assay` slot for clustering, or even two different `assays` for clustering and visualization. `clusterExperiment` allows for this level of flexibility, by using the `whichAssay` option in all the relevant functions.

Our `se` object has different assays, which we can see with the `assayNames` function:

```{r slotnames}
assayNames(se)
```


**Switching between assays and transformations** If you plan to use different assays for different functions, be careful about the built-in transformation function that is saved in `ClusterExperiment` objects -- and which will be applied to any assay! The data will be silently transformed by pretty much every function in the package before any calculations are performed. You can set the transformation function with the command `transformation(x)<-...`, including setting it to the identify `function(x){x}`. If you plan on using a dimensionality reduction like PCA, then if they are already saved in the object (using `reducedDims`) then the functions in the `RSEC` workflow will use those and not need to transform the data. But setting `isCount=TRUE` in `RSEC` will set the transformation of the object (and also by default sets the `DEMethod` for `mergeClusters` unless the user over-rides it) even if RSEC uses the saved dimensionality reductions and the data is never transformed for the clustering analysis. 

[^1]: `scRNAseq` also provides multiple gene summaries of the data, and we save only the "tophat_counts" and "rsem_tpm" values. 

# Session Information
This vignette was compiled under:

```{r sessionInfo}
sessionInfo()
```


# References
